
/*
 * ESP32-C6: LittleFS の /commands1.txt から AT コマンドを順次実行（UART1）
 * - LCD（LovyanGFX/ST7789）へ CMD/RSP 表示、WS2812 で結果表示
 * - ログ: /logs/atlog_YYYYMMDD_HHMMSS.txt（+CCLK 時刻／なければ millis）
 * - PC→ESP32: #LIST / #GET <path> / #DELLOG（FILEBEGIN size + 本体 + FILEEND）
 *
 * 主要仕様（2026-01-15版 + 要望反映）
 * - 全 AT コマンドの個別タイムアウトは 10 秒に統一（COPS も 10s/試行・延長なし）
 * - コマンド間の待ち時間は 1,000ms（advanceWhenReady）
 * - /commands1.txt に "WAIT <msec>" 行を記述すると、その msec だけ delay。表示は LCD のみ（ログ・PC出力なし）
 * - 2回目以降の実行は #STEP2 の次行から開始（見つからなければ先頭）
 * - 送受一致判定：送受ペイロードを同じ規則（makePrintable）で正規化して比較（受信HEX→バイト化）
 * - Pass拡張：途中ERRORがあっても「送受抽出＋RSRP取得」達成で青LED・カウントアップ
 * - MISMATCH/INCOMPLETE は“エラー扱い”としてログ保存（error_log_）＋NGカウント＋赤LED
 * - 復帰：GPIO20 LOW→約1秒→HIGH→固定6秒→AT→OK 無期限待ちで再開
 * - AT%SOCKETCMD="ALLOCATE" の ERROR リトライ前は 1 秒待機
 * - 2回目以降は AT%SOCKETCMD="ALLOCATE",1*** の ERROR を完全無視（ログ/シリアル出力せずに次へ）
 * - 実行間隔は30min
 */

#include <Arduino.h>
#include <FS.h>
#include <LittleFS.h>
#include <LovyanGFX.hpp>
#include <Adafruit_NeoPixel.h>
#include <vector>
#include "lte_mod.h"

#if defined(ESP32)
  #include "freertos/FreeRTOS.h"
  #include "freertos/portmacro.h"
  portMUX_TYPE gp23Mux = portMUX_INITIALIZER_UNLOCKED;
  #ifndef IRAM_ATTR
  #define IRAM_ATTR
  #endif
#endif

/* ==================== グローバル設定・ユーティリティ ==================== */
bool pcTransferActive = false;
#define PC_PRINT(s)    do{ if(!pcTransferActive) Serial.print(s); } while(0)
#define PC_PRINTLN(s)  do{ if(!pcTransferActive) Serial.println(s); } while(0)
#define PC_PRINTF(...) do{ if(!pcTransferActive) Serial.printf(__VA_ARGS__); } while(0)

#define RGB_PIN   8
#define RGB_COUNT 1
Adafruit_NeoPixel rgb(RGB_COUNT, RGB_PIN, NEO_RGB + NEO_KHZ800);
inline void rgbSet(uint8_t r, uint8_t g, uint8_t b){ rgb.setPixelColor(0, rgb.Color(r,g,b)); rgb.show(); }
inline void showMatch()    { rgbSet(0, 0, 255); } // 青
inline void showMismatch() { rgbSet(255, 0, 0); } // 赤
inline void showIdle()     { rgbSet(0, 0, 0); }

class LGFX_ESP32C6_WS : public lgfx::LGFX_Device{
  lgfx::Panel_ST7789 _panel; lgfx::Bus_SPI _bus; lgfx::Light_PWM _light;
public:
  LGFX_ESP32C6_WS(void){
    { auto cfg=_bus.config(); cfg.spi_host=SPI2_HOST; cfg.spi_mode=0; cfg.freq_write=20000000; cfg.freq_read=10000000;
      cfg.spi_3wire=false; cfg.use_lock=true; cfg.dma_channel=SPI_DMA_CH_AUTO; cfg.pin_sclk=7; cfg.pin_mosi=6; cfg.pin_miso=-1; cfg.pin_dc=15;
      _bus.config(cfg); _panel.setBus(&_bus); }
    { auto cfg=_panel.config(); cfg.pin_cs=14; cfg.pin_rst=21; cfg.pin_busy=-1; cfg.memory_width=172; cfg.memory_height=320;
      cfg.panel_width=172; cfg.panel_height=320; cfg.offset_x=0; cfg.offset_y=0; cfg.invert=false; cfg.rgb_order=false; cfg.readable=false; cfg.bus_shared=false;
      _panel.config(cfg); }
    { auto cfg=_light.config(); cfg.pin_bl=22; cfg.freq=5000; cfg.pwm_channel=0; _light.config(cfg); _panel.setLight(&_light); }
    setPanel(&_panel);
  }
};
LGFX_ESP32C6_WS lcd;
static const int margin=8;
int cursorX=margin, cursorY=margin;
int lineHeight=0, textSize=1;
int responseLineCount=0;
bool isRunning=false;
bool idleHoldDisplay=false;
unsigned long lastRunMillis=0;

/* ==== タイムアウト・間隔 ==== */
const unsigned long COMMAND_RESPONSE_TIMEOUT_MS = 10000UL; // 10s
const unsigned long RUN_INTERVAL_MS            = 1800000UL;  // 周期実行間隔 (30 min x 60,000 msec)
const unsigned long INTER_CMD_DELAY_MS         = 1000UL;   // コマンド間
uint32_t ngCountRun=0, passCountRun=0;

/* ==== ERROR 復帰用 GPIO20 ==== */
unsigned long gpio20LowTime=0; bool gpio20IsLow=false;
const unsigned long GPIO20_LOW_DURATION_MS=1000; // LOW→約1秒後HIGH
bool pendingRestartAfterError=false;

/* ==== RSRP 情報 ==== */
String rsrpInfo=""; bool hasRsrpInfo=false; String lastRsrpInfo=""; bool hasLastRsrp=false;

/* ==== 復帰待ち（AT→OK 無期限待ち） ==== */
bool waitingModemReady = false;
unsigned long modemReadyWaitStartMs = 0;
unsigned long lastProbeMs = 0;
const unsigned long PROBE_INTERVAL_MS = 500; // 500ms 毎に AT

/* ==================== GP23: 割り込みスイッチ ==================== */
#define GP23_SWITCH_PIN 23
bool userPauseEnabled = false;
volatile bool gp23IsrEvent = false;
static bool swDebouncing = false;
static unsigned long swDebounceStartMs = 0;
static unsigned long lastSwitchHandledMs = 0;
const unsigned long SWITCH_DEBOUNCE_MS = 30;
const unsigned long SWITCH_LOCK_MS     = 5000;

void IRAM_ATTR gp23_isr(){
#if defined(ESP32)
  portENTER_CRITICAL_ISR(&gp23Mux);
#endif
  gp23IsrEvent = true;
#if defined(ESP32)
  portEXIT_CRITICAL_ISR(&gp23Mux);
#endif
}

/* ==================== ログ（LittleFS） ==================== */
String logFilePath=""; fs::File logFile; bool logReady=false;
bool hasClockFromModem=false; String currentClockStr="";

bool ensureFS(){ if(!LittleFS.begin(true)){ PC_PRINTLN("[ERROR] Failed to mount LittleFS"); return false; } return true; }
static String pad2(int v){ String s=String(v); if(s.length()<2) s="0"+s; return s; }

String cclkToFilenameStamp(const String &cclk){
  int q1=cclk.indexOf('"'), q2=cclk.lastIndexOf('"');
  String core=(q1>=0&&q2>q1)? cclk.substring(q1+1,q2):cclk;
  int s1=core.indexOf('/'), s2=core.indexOf('/',s1+1), comma=core.indexOf(','), c1=core.indexOf(':',comma+1), c2=core.indexOf(':',c1+1);
  if(s1<0 || s2<0 || comma<0 || c1<0 || c2<0) return String(millis()/1000)+"s";
  String yy=core.substring(0,s1), MM=core.substring(s1+1,s2), dd=core.substring(s2+1,comma);
  String hh=core.substring(comma+1,c1), mm=core.substring(c1+1,c2), ss=core.substring(c2+1,c2+3);
  return String("20")+yy+pad2(MM.toInt())+pad2(dd.toInt())+"_"+pad2(hh.toInt())+pad2(mm.toInt())+pad2(ss.toInt());
}

String makeLogFilePath(){
  String stamp=(hasClockFromModem && currentClockStr.length()>0)? cclkToFilenameStamp(currentClockStr) : String(millis()/1000)+"s";
  return String("/logs/atlog_")+stamp+String(".txt");
}

void openNewLog(){
  if(!ensureFS()){ logReady=false; return; }
  LittleFS.mkdir("/logs");
  logFilePath=makeLogFilePath();
  logFile=LittleFS.open(logFilePath,"a");
  if(!logFile){ PC_PRINTF("[ERROR] Failed to open log file: %s\n", logFilePath.c_str()); logReady=false; return; }
  logReady=true;
  PC_PRINTF("[LOG] Opened: %s\n", logFilePath.c_str());
  logFile.printf("=== AT Log start ===\nfile: %s\n", logFilePath.c_str());
  logFile.flush();
}

void closeLog(){ if(logReady){ logFile.printf("=== AT Log end ===\n"); logFile.flush(); logFile.close(); logReady=false; } }

String nowStamp(){
  if(hasClockFromModem && currentClockStr.length()>0){
    int q1=currentClockStr.indexOf('"'), q2=currentClockStr.lastIndexOf('"');
    String core=(q1>=0&&q2>q1)? currentClockStr.substring(q1+1,q2):currentClockStr;
    return String("[")+String("20")+core+String("]");
  }
  return String("[")+String(millis()/1000)+String("s]");
}

void logWrite(const String &line){ if(!logReady) return; logFile.printf("%s %s\n", nowStamp().c_str(), line.c_str()); logFile.flush(); }

/* ==================== 表示ユーティリティ ==================== */
void drawHeaderWithStatus(){
  lcd.setCursor(margin, margin); lcd.println("AT Command Executor");
  cursorY=margin+lineHeight; cursorX=margin;
  lcd.setCursor(cursorX, cursorY);
  lcd.printf("NG:%03lu Pass:%03lu",(unsigned long)ngCountRun,(unsigned long)passCountRun);
  cursorY+=lineHeight;
  lcd.drawLine(margin,cursorY,lcd.width()-margin,cursorY,TFT_DARKGREY);
  cursorY+=(lineHeight/4);
}
void lcdClearBeforeNewLine(bool drawHeader=true){ lcd.fillScreen(TFT_BLACK); cursorX=margin; cursorY=margin; if(drawHeader) drawHeaderWithStatus(); }
void lcdNewLine(){ cursorX=margin; cursorY+=lineHeight; if(cursorY>lcd.height()-margin-lineHeight) lcdClearBeforeNewLine(); }
void lcdPrintLine(const String& line){ lcd.setCursor(cursorX,cursorY); lcd.print(line); lcdNewLine(); }


/* ==================== UART1 制御 ==================== */
static const uint32_t BAUD_PC=115200, BAUD_UART=115200;
static const int UART1_TX_PIN=18, UART1_RX_PIN=19;
void uart1Enable(){ Serial1.begin(BAUD_UART, SERIAL_8N1, UART1_RX_PIN, UART1_TX_PIN); Serial1.setRxBufferSize(4096); PC_PRINTLN("[UART1] Enabled"); }
void uart1Disable(){ Serial1.end(); PC_PRINTLN("[UART1] Disabled"); }

/* ==================== GP23: 中断/再開 ==================== */
void pauseProcessing(){
  if (userPauseEnabled) return;
  userPauseEnabled = true;
  if (isRunning){
    waitingForCommandResponse = false;
    uart1Disable();
    isRunning = false;
    logWrite("USER PAUSE (GP23 IRQ): processing paused");
    lcdClearBeforeNewLine(); lcdPrintLine("PAUSED by GP23"); showIdle();
  }else{
    logWrite("USER PAUSE (GP23 IRQ): idle");
    lcdClearBeforeNewLine(); lcdPrintLine("PAUSED (idle) by GP23"); showIdle();
  }
}
void resumeProcessing(){
  if (!userPauseEnabled) return;
  userPauseEnabled = false;
  logWrite("USER RESUME (GP23 IRQ): processing resumed");
  startRun();
}
void handlePauseSwitchIrqDriven(){
  bool event = false;
#if defined(ESP32)
  portENTER_CRITICAL(&gp23Mux);
#endif
  if (gp23IsrEvent){ event = true; gp23IsrEvent = false; }
#if defined(ESP32)
  portEXIT_CRITICAL(&gp23Mux);
#endif
  unsigned long now = millis();
  if (event){ swDebouncing = true; swDebounceStartMs = now; }
  if (swDebouncing && (now - swDebounceStartMs >= SWITCH_DEBOUNCE_MS)){
    if (digitalRead(GP23_SWITCH_PIN) == LOW){
      if (now - lastSwitchHandledMs >= SWITCH_LOCK_MS){
        if (userPauseEnabled) resumeProcessing();
        else pauseProcessing();
        lastSwitchHandledMs = now;
      }
    }
    swDebouncing = false;
  }
}

/* ==================== ファイルロード & STEP2 対応 ==================== */
uint32_t runCycleCount = 0; // 1回目=TOP、2回目以降=STEP2以降
int step2StartIndexCache = -1;

int findStep2StartIndex() {
  for (size_t i=0; i<commandLines.size(); ++i) {
    String line = commandLines[i];
    if (line.startsWith("#STEP2")) {
      return (int)i + 1; // 次行
    }
  }
  return 0;
}
void loadCommandFile(){
  if(!ensureFS()) return;
  fs::File file=LittleFS.open("/commands1.txt","r");
  if(!file){ PC_PRINTLN("[ERROR] Failed to open commands1.txt"); return; }
  commandLines.clear();
  while(file.available()){
    String line=file.readStringUntil('\n'); line.trim();
    if(line.length()>0) commandLines.push_back(line);
  }
  file.close();
  PC_PRINTF("[INFO] Loaded %d lines from commands1.txt\n",(int)commandLines.size());
  commandsLoaded=true;
  step2StartIndexCache = findStep2StartIndex();
}

/* ==================== 画面（アイドル） ==================== */
void showIdleNextRunScreen(){
  lcdClearBeforeNewLine();
  String rsrpLine;
  if(hasRsrpInfo && rsrpInfo.length()>0){ rsrpLine=rsrpInfo; lastRsrpInfo=rsrpInfo; hasLastRsrp=true; }
  else if(hasLastRsrp && lastRsrpInfo.length()>0){ rsrpLine=lastRsrpInfo; }
  else { rsrpLine="RSRP: N/A"; }
  lcdPrintLine(rsrpLine);
  lcdPrintLine(String("Next run in ") + (RUN_INTERVAL_MS/60000) + " minitues...");
  idleHoldDisplay=true;
}

/* ==================== 実行サイクル（ログ保存ポリシー含む） ==================== */
bool errorOccurredThisRun = false; // ラン単位エラーフラグ（AT ERROR / MISMATCH / INCOMPLETE）

void startRun(){
  idleHoldDisplay=false; hasSendData=false; hasReceiveData=false; hasRsrpInfo=false; rsrpInfo="";
  waitingForCommandResponse=false; showIdle();
  lcdClearBeforeNewLine(); lcdPrintLine("Loading commands...");
  runCycleCount++;
  errorOccurredThisRun = false;

  loadCommandFile();

  int startIndex = 0;
  if (runCycleCount >= 2) { startIndex = (step2StartIndexCache >= 0 ? step2StartIndexCache : 0); }
  currentLineIndex = startIndex;

  if (runCycleCount == 1) { lcdPrintLine("Start: from TOP");      logWrite("RUN START: from TOP"); }
  else {
    if (startIndex > 0)   { lcdPrintLine("Start: from #STEP2");   logWrite("RUN START: from #STEP2"); }
    else                  { lcdPrintLine("Start: #STEP2 not found -> TOP"); logWrite("RUN START: #STEP2 not found -> TOP"); }
  }

  uart1Enable();
  isRunning=true; delay(300);
  openNewLog(); logWrite("RUN START");
  sendNextCommand();
}
void finishRun(){
  uart1Disable();
  isRunning=false; lastRunMillis=millis();
  showIdleNextRunScreen();
  PC_PRINTLN("[INFO] Waiting for next run interval");
  logWrite("RUN END");
  closeLog();

  // ログ保存ポリシー：エラー（AT ERROR / MISMATCH / INCOMPLETE）なら保存、なければ削除
  if (!ensureFS()) return;
  if (logFilePath.length() == 0) return;
  if (errorOccurredThisRun) {
    if (logFilePath.indexOf("/logs/error_log_") == 0) {
      PC_PRINTLN("[LOG] Error occurred; file already named with error_log_ (kept)");
    } else {
      String baseName = logFilePath.substring(String("/logs/").length());
      String newPath = String("/logs/error_log_") + baseName;
      bool ok = LittleFS.rename(logFilePath, newPath);
      if (ok) { PC_PRINTF("[LOG] Error occurred; renamed to: %s\n", newPath.c_str()); logFilePath = newPath; }
      else    { PC_PRINTF("[ERROR] Failed to rename log to: %s (kept original)\n", newPath.c_str()); }
    }
  } else {
    if (LittleFS.exists(logFilePath)) {
      bool ok = LittleFS.remove(logFilePath);
      if (ok) PC_PRINTF("[LOG] No error; log removed: %s\n", logFilePath.c_str());
      else    PC_PRINTF("[ERROR] Failed to remove log: %s\n", logFilePath.c_str());
    }
  }
}
void restartFromTop(){
  PC_PRINTLN("[RESTART] Restarting from line 1");
  idleHoldDisplay=false; isRunning=true; waitingForCommandResponse=false;
  hasSendData=false; hasReceiveData=false; hasRsrpInfo=false; rsrpInfo="";
  sendDataString=""; receiveDataString=""; currentLineIndex=0;
  lcdClearBeforeNewLine(true); lcdPrintLine("Restarting from line 1...");
  loadCommandFile(); delay(300);
  logWrite("RESTART FROM TOP");
  uart1Enable();
  sendNextCommand();
}

/* ==================== コマンド送出 ==================== */
void advanceWhenReady(){ delay(INTER_CMD_DELAY_MS); sendNextCommand(); }
void sendNextCommand(){
  if(!commandsLoaded || currentLineIndex >= (int)commandLines.size()){
    PC_PRINTLN("[INFO] All commands completed");
    bool rsrpObtained = (hasRsrpInfo || hasLastRsrp);
    if (hasSendData && hasReceiveData && rsrpObtained) {
      showMatch(); passCountRun++;
      logWrite("RESULT: PASS_BY_COMPLETION (send/receive/RSRP obtained)");
    } else {
      if(hasSendData && hasReceiveData){
        if(sendDataString.equals(receiveDataString)){
          showMatch(); passCountRun++; logWrite("RESULT: MATCH");
        } else {
          showMismatch(); ngCountRun++; logWrite("RESULT: MISMATCH");
          errorOccurredThisRun = true;  // MISMATCH をエラー扱い
        }
      } else {
        logWrite("RESULT: INCOMPLETE (missing send/receive and/or RSRP)");
        showMismatch(); ngCountRun++;
        errorOccurredThisRun = true;    // INCOMPLETE もエラー扱い
      }
    }
    finishRun(); return;
  }

  String command=commandLines[currentLineIndex];

  if(command.startsWith("#")){ currentLineIndex++; sendNextCommand(); return; } // コメント
  if(command.startsWith("WAIT")){
    int sp = command.indexOf(' '); unsigned long waitMs = 0;
    if(sp > 0){ String msStr = command.substring(sp+1); msStr.trim(); waitMs = (unsigned long)msStr.toInt(); }
    lcdClearBeforeNewLine(); lcdPrintLine(String("WAIT ") + waitMs + " ms...");
    delay(waitMs);
    currentLineIndex++; sendNextCommand(); return;
  }

  // %SOCKETDATA SEND の payload を抽出（比較用に正規化保持）
  int scid=0, slen=0; String spayloadRaw;
  bool isSendCmd = parseSocketdataSendCmd(command, scid, slen, spayloadRaw);
  if(isSendCmd){
    String spNorm = makePrintable(spayloadRaw);
    if(spNorm.length()>26) spNorm = spNorm.substring(0,26);
    sendDataString = spNorm; hasSendData = true;
    PC_PRINTF("[INFO] SEND cid=%d len=%d payload_norm(<=26): %s\n", scid, slen, sendDataString.c_str());
    logWrite(String("SEND PAYLOAD (cid=")+scid+", len="+slen+"): "+sendDataString);
  }

  // 送信
  lcdClearBeforeNewLine(); lcdPrintLine("CMD: "+command);
  PC_PRINTF("[TX->UART1] %s\n", command.c_str());
  Serial1.print(command); Serial1.print("\r\n");
  currentCommandStr = command;
  waitingForCommandResponse=true;
  commandSentTime=millis();
  responseLineCount=0;
  errorRetryAttempts = 0;

  // タイムアウト設定
  if(command.equals("AT+COPS=1,2,\"44020\"")){
    isCopsCommandActive = true; copsAttempts = 1; copsSawHex = false;
    currentCommandTimeoutMs = COPS_TIMEOUT_PER_TRY_MS;
    logWrite("COPS: special handling started (timeout=10s per try, no extension)");
  }else{
    isCopsCommandActive = false; copsAttempts = 0; copsSawHex = false;
    currentCommandTimeoutMs = COMMAND_RESPONSE_TIMEOUT_MS;
    logWrite("DEFAULT: per-command response timeout = 10s");
  }
  logWrite(String("CMD: ")+command);
}

/* ==================== 例外ルール: ALLOCATE,1*** の ERROR 抑止（2回目以降） ==================== */
inline bool allocate1ExceptionActive() {
  return (runCycleCount >= 2) && currentCommandStr.startsWith("AT%SOCKETCMD=\"ALLOCATE\",1");
}

/* ==================== PC→ESP32：#LIST / #GET / #DELLOG（loopより前に定義） ==================== */
void handlePcSerialCommands(){
  static String line;
  while(Serial.available()){
    char c=(char)Serial.read();
    if(c=='\n' || c=='\r'){
      if(line.length()==0) continue;
      String cmd=line; line=""; cmd.trim();

      if(cmd=="#LIST"){
        fs::File root=LittleFS.open("/logs");
        if(!root || !root.isDirectory()){ Serial.print("ERR:/logs open failed\r\n"); return; }
        fs::File f=root.openNextFile();
        while(f){ Serial.printf("LIST:%s:%u\r\n", f.path(), (unsigned)f.size()); f=root.openNextFile(); }
        root.close(); Serial.print("LISTEND\r\n"); return;
      }
      if(cmd.startsWith("#GET ")){
        String path=cmd.substring(5); path.trim();
        fs::File f=LittleFS.open(path,"r");
        if(!f){ Serial.printf("ERR:open %s failed\r\n", path.c_str()); return; }
        pcTransferActive=true;
        size_t sz=f.size();
        Serial.printf("FILEBEGIN %s %u\r\n", path.c_str(), (unsigned)sz);
        uint8_t buf[1024];
        while(f.available()){ size_t n=f.read(buf,sizeof(buf)); Serial.write(buf,n); yield(); }
        f.close();
        Serial.print("FILEEND\r\n");
        pcTransferActive=false; return;
      }
      if(cmd=="#DELLOG"){
        fs::File root=LittleFS.open("/logs");
        if(!root || !root.isDirectory()){ Serial.print("DELLOG:EMPTY\r\n"); return; }
        size_t files=0, bytes=0;
        fs::File f=root.openNextFile();
        while(f){ String path=f.path(); size_t sz=f.size(); f.close(); if(LittleFS.remove(path)){ files++; bytes+=sz; } f=root.openNextFile(); }
        root.close(); LittleFS.mkdir("/logs");
        Serial.printf("DELLOG:OK %u %u\r\n",(unsigned)files,(unsigned)bytes); return;
      }
      Serial.print("ERR:unknown cmd\r\n");
    }else{
      line+=c;
    }
  }
}

/* ==================== UART1受信（行確定）…通常関数として定義 ==================== */
static std::vector<uint8_t> uart1Buf;
static uint32_t uart1LastByteMs=0;
static const uint32_t UART1_GAP_MS=15;

bool uart1GetLine(String &out){
  bool got=false;
  // 復帰待ち中も受信を見る
  if(!isRunning && !waitingModemReady) return false;
  while(Serial1.available()){
    uint8_t b=(uint8_t)Serial1.read(); uart1LastByteMs=millis();
    if(b=='\r') continue;
    if(b=='\n'){
      if(!uart1Buf.empty()){
        out.reserve(uart1Buf.size());
        for(auto v:uart1Buf) out+=(char)v;
        uart1Buf.clear();
        return true;
      }else continue;
    }
    uart1Buf.push_back(b);
    if(uart1Buf.size()>4096){
      out.reserve(uart1Buf.size());
      for(auto v:uart1Buf) out+=(char)v;
      uart1Buf.clear();
      return true;
    }
  }
  if(!uart1Buf.empty()){
    uint32_t now=millis();
    if(now - uart1LastByteMs >= UART1_GAP_MS){
      out.reserve(uart1Buf.size());
      for(auto v:uart1Buf) out+=(char)v;
      uart1Buf.clear();
      got=true;
    }
  }
  return got;
}

/* ==================== setup / loop ==================== */
void setup(){
  Serial.begin(115200); delay(300);
  ensureFS(); LittleFS.mkdir("/logs");
  pinMode(20, OUTPUT); digitalWrite(20, HIGH); PC_PRINTLN("[GPIO20] Set to HIGH");
  pinMode(GP23_SWITCH_PIN, INPUT_PULLUP);
  attachInterrupt(GP23_SWITCH_PIN, gp23_isr, FALLING);

  delay(2000); // LCD 初期化前待機
  lcd.begin(); lcd.setRotation(1); lcd.setBrightness(220);
  lcd.setFont(&fonts::Font4); lcd.setTextSize(textSize);
  lcd.setTextColor(TFT_WHITE, TFT_BLACK);
  lcd.setTextDatum(textdatum_t::top_left);
  lineHeight=lcd.fontHeight()*textSize;

  lcdClearBeforeNewLine(); lcdPrintLine("READY - Log + Transfer (interval, UART1 off in idle)");
  rgb.begin(); rgb.show(); showIdle();

  delay(3000); // LCD 初期化前待機
  lastRunMillis=millis();
  startRun();
}

void loop(){
  handlePcSerialCommands();
  if(pcTransferActive) return;

  handlePauseSwitchIrqDriven();
  if(userPauseEnabled) return;

  /* ==== GPIO20 自動復帰（LOW→約1秒→HIGH） ==== */
  if(gpio20IsLow && (millis()-gpio20LowTime >= GPIO20_LOW_DURATION_MS)){
    digitalWrite(20, HIGH); gpio20IsLow=false; PC_PRINTLN("[GPIO20] Set to HIGH (timeout recovery)");
    if(pendingRestartAfterError){
      pendingRestartAfterError=false;
      lcdPrintLine("Waiting 6s for module reboot...");
      logWrite("EVENT: GPIO20 HIGH; fixed 6s wait before AT probe");
      delay(6000);
      waitingModemReady = true;
      modemReadyWaitStartMs = millis();
      lastProbeMs = 0;
      isRunning = false; waitingForCommandResponse = false;
      uart1Enable(); // 念のため
      lcdClearBeforeNewLine();
      lcdPrintLine("Probing: send AT until OK (no timeout)...");
      logWrite("EVENT: Start AT probing (wait OK, no timeout)");
      Serial1.print("AT\r\n");
      lastProbeMs = millis();
      return;
    }
  }

  /* ==== 復帰待ち（AT→OK） ==== */
  if (waitingModemReady) {
    unsigned long now = millis();
    if (now - lastProbeMs >= PROBE_INTERVAL_MS) {
      Serial1.print("AT\r\n");
      lastProbeMs = now;
    }
  }

  /* ==== 自動実行（インターバル） ==== */
  if(!isRunning && !waitingModemReady && (millis()-lastRunMillis >= RUN_INTERVAL_MS)){
    startRun();
  }

  /* ==== レスポンスタイムアウト監視 ==== */
  if(isRunning && waitingForCommandResponse &&
     (millis()-commandSentTime >= currentCommandTimeoutMs)){
    if(isCopsCommandActive && copsAttempts < COPS_MAX_ATTEMPTS){
      PC_PRINTF("[COPS] Timeout after %lu ms -> retry %d/%d (no extension)\n",
        (unsigned long)currentCommandTimeoutMs, copsAttempts+1, COPS_MAX_ATTEMPTS);
      logWrite(String("TIMEOUT: COPS ")+String(currentCommandTimeoutMs/1000)+"s, retry "+String(copsAttempts+1)+"/"+String(COPS_MAX_ATTEMPTS));
      Serial1.print(currentCommandStr); Serial1.print("\r\n");
      copsAttempts++;
      commandSentTime = millis();
      responseLineCount=0;
      waitingForCommandResponse = true;
    }else{
      PC_PRINTLN("[TIMEOUT] No response - Moving to next command");
      logWrite(String("TIMEOUT: ")+String(currentCommandTimeoutMs/1000)+"s");
      waitingForCommandResponse=false;
      currentLineIndex++;
      if(isCopsCommandActive){ isCopsCommandActive=false; }
      advanceWhenReady();
    }
  }

  /* ==== UART1 受信・解析 ==== */
  String resp;
  if(uart1GetLine(resp)){
    String printable=makePrintable(resp);

    // OK/ERROR 判定を先に
    String line = printable; line.trim();
    bool isOk = (line == "OK");
    bool isError = (line == "ERROR");

    // 2回目以降の ALLOCATE,1*** 例外：ERROR を完全無視（ログ・シリアル抑止）
    bool suppressError = (isError && isRunning && waitingForCommandResponse && allocate1ExceptionActive());

    if(!suppressError){
      PC_PRINT("[RX<-UART1] "); PC_PRINTLN(printable);
    }

    responseLineCount++;
    if(!isRunning && idleHoldDisplay) return;

    // COPS: HEX 検知（ログのみ）
    if(isCopsCommandActive && printable.indexOf('<')>=0){
      logWrite("COPS: hex-like stream detected");
    }

    // %SOCKETDATA 抽出
    int rcid=0, rlen=0, rflags=0; String rpayloadRaw;
    if(parseSocketdataRx(printable, rcid, rlen, rflags, rpayloadRaw)){
      String rpNorm;
      if(isPureHexString(rpayloadRaw)){
        rpNorm = makePrintable(hexToBytesString(rpayloadRaw));
      }else{
        rpNorm = makePrintable(rpayloadRaw);
      }
      if(rpNorm.length()>26) rpNorm = rpNorm.substring(0,26);
      receiveDataString = rpNorm; hasReceiveData = true;
      PC_PRINTF("[INFO] RECEIVE cid=%d len=%d flags=%d payload_norm(<=26): %s\n", rcid, rlen, rflags, receiveDataString.c_str());
      logWrite(String("RECEIVE PAYLOAD (cid=")+rcid+", len="+rlen+", flags="+rflags+"): "+receiveDataString);
    }

    // +CCLK
    if(printable.indexOf("+CCLK:")>=0){ currentClockStr=printable; hasClockFromModem=true; logWrite(String("CLOCK UPDATE: ")+printable); }

    // RSRP
    if(printable.indexOf("RSRP: Reported")>=0){
      int s=printable.indexOf("RSRP: Reported"), c=printable.indexOf(',',s);
      rsrpInfo=(c>s)? printable.substring(s,c): printable.substring(s);
      rsrpInfo.replace("Reported ",""); rsrpInfo+=" dBm";
      hasRsrpInfo=true; lastRsrpInfo=rsrpInfo; hasLastRsrp=true;
      PC_PRINTF("[INFO] RSRP info captured: %s\n", rsrpInfo.c_str());
      logWrite(String("RSRP: ")+rsrpInfo);
    }

    // LCD 短縮表示
    if(printable.length()>0){
      String d=(printable.length()>20)? printable.substring(0,17)+"..." : printable;
      lcdPrintLine("RSP: "+d);
    }

    // 復帰待ち完了（AT->OK）
    if(isOk && waitingModemReady){
      waitingModemReady = false;
      logWrite("EVENT: Modem ready confirmed (AT -> OK)");
      lcdPrintLine("Modem ready. Restarting sequence...");
      delay(200);
      restartFromTop();
      yield();
      return;
    }

    // OK 応答：通常遷移
    if(isOk){
      if (waitingForCommandResponse){
        waitingForCommandResponse=false;
        if(isCopsCommandActive) isCopsCommandActive=false;
        currentLineIndex++;
        logWrite("CMD: OK received");
        advanceWhenReady();
        logWrite(String("RSP: ")+printable);
      }else{
        logWrite(String("URC: ")+printable);
      }
      yield();
      return;
    }

    // 例外：ALLOCATE,1*** の ERROR は完全スキップ
    if(suppressError){
      waitingForCommandResponse=false;
      if(isCopsCommandActive) isCopsCommandActive=false;
      currentLineIndex++;
      advanceWhenReady();
      yield();
      return;
    }

    // 通常の ERROR 処理
    if(isError){
      errorOccurredThisRun = true; // エラー扱い（ログ保存対象）
      if (!waitingForCommandResponse){
        logWrite(String("URC: ")+printable);
        yield();
        return;
      }
      logWrite(String("RSP: ")+printable);

      if(errorRetryAttempts < MAX_ERROR_RETRY){
        // ALLOCATE の ERROR は再送前に 1 秒待機（例外に該当しない場合のみ）
        if (currentCommandStr.startsWith("AT%SOCKETCMD=\"ALLOCATE\"")) {
          PC_PRINTLN("[RETRY] ERROR on ALLOCATE -> wait 1000ms then retry");
          logWrite("RETRY: ALLOCATE ERROR -> wait 1000ms before resend");
          delay(1000);
        }
        PC_PRINTF("[RETRY] ERROR received -> retry %d/%d (cmd=%s)\n",
          errorRetryAttempts+1, MAX_ERROR_RETRY, currentCommandStr.c_str());
        logWrite(String("ERROR: retry ")+String(errorRetryAttempts+1)+"/"+String(MAX_ERROR_RETRY));
        Serial1.print(currentCommandStr); Serial1.print("\r\n");
        errorRetryAttempts++;
        commandSentTime = millis();
        responseLineCount=0;
        waitingForCommandResponse = true;
        yield();
        return;
      }else{
        waitingForCommandResponse=false;
        if(isCopsCommandActive){ isCopsCommandActive=false; }
        ngCountRun++; showMismatch();
        if(!gpio20IsLow){
          digitalWrite(20,LOW); gpio20IsLow=true; gpio20LowTime=millis();
          PC_PRINTLN("[GPIO20] LOW (ERROR reset sequence started)");
        }
        pendingRestartAfterError=true;
        lcdClearBeforeNewLine();
        lcdPrintLine("RSP: ERROR (max retries). Reset GPIO20 -> wait 6s");
        logWrite("EVENT: ERROR after max retries; GPIO20 LOW; pending restart");
        currentLineIndex++;
        advanceWhenReady();
        yield();
        return;
      }
    }

    // その他の行はログへ
    logWrite(String("RSP: ")+printable);
    yield();
  }
}
